# 1.1 - Conceitos Principais da Engine

Para usar a JDStudio Engine de forma eficaz, é crucial entender seus quatro pilares arquitetônicos.

### 1. A Máquina de Estados (`GameState`)

O fluxo do jogo é controlado por uma **Máquina de Estados**. Toda a lógica é separada em "estados" (menu, fase, game over, etc.). A engine gerencia os estados em uma **pilha**, permitindo sobrepor telas (ex: menu de pausa sobre o jogo). Apenas o estado no topo da pilha é atualizado (`tick`), mas todos são renderizados, permitindo a criação de HUDs e efeitos de transparência.

-   **`GameState`**: Classe abstrata que define um estado.
-   **`EnginePlayingState`**: Especialização para fases, gerenciando `GameObject`s.
-   **`EngineMenuState`**: Especialização para menus, gerenciando um `UIManager`.

---

### Resolução Base e Escala: Como Funciona o Visual do Seu Jogo

Um dos primeiros passos ao iniciar seu projeto é definir a resolução base do jogo. Isso afeta diretamente o visual, o campo de visão e a experiência do jogador.

- **width** e **height**: São a resolução interna do seu jogo, ou seja, o número de pixels que você realmente desenha e manipula. É nesta resolução que tudo acontece.
- **scale**: É o multiplicador que "estica" a resolução base para criar a janela final no monitor do jogador, mantendo os pixels quadrados e nítidos.
- **Resolução Final**: Será `(width * scale)` por `(height * scale)`.

#### Tabela de Resoluções Recomendadas por Tamanho de Tile

| Tamanho do Tile | Resolução Base (Width x Height) | Aspect Ratio | Inspiração / Estilo | Exemplo de Janela Final (com scale) |
|-----------------|-------------------------------|--------------|---------------------|-------------------------------------|
| 16x16           | 256 x 144                     | 16:9         | Estilo GBA moderno  | scale = 4 → 1024 x 576 <br> scale = 5 → 1280 x 720 (HD) |
| 16x16           | 240 x 160                     | 3:2          | Game Boy Advance    | scale = 3 → 720 x 480 <br> scale = 4 → 960 x 640 |
| 16x16           | 320 x 180                     | 16:9         | Pixel art HD        | scale = 3 → 960 x 540 <br> scale = 4 → 1280 x 720 (HD) |
| 16x16           | 256 x 224                     | 8:7          | SNES / Mega Drive   | scale = 3 → 768 x 672 <br> scale = 4 → 1024 x 896 |
| 24x24           | 384 x 216                     | 16:9         | HD, tiles maiores   | scale = 3 → 1152 x 648 <br> scale = 4 → 1536 x 864 |
| 24x24           | 480 x 270                     | 16:9         | HD, detalhe elevado | scale = 2 → 960 x 540 <br> scale = 3 → 1440 x 810 |
| 32x32           | 320 x 180                     | 16:9         | Moderno, 10 tiles   | scale = 3 → 960 x 540 <br> scale = 4 → 1280 x 720 (HD) |
| 32x32           | 384 x 224                     | ~16:9        | PC anos 90          | scale = 2 → 768 x 448 <br> scale = 3 → 1152 x 672 |
| 32x32           | 480 x 270                     | 16:9         | UI densa            | scale = 2 → 960 x 540 <br> scale = 3 → 1440 x 810 |
| 48x48           | 480 x 270                     | 16:9         | 10 tiles de largura | scale = 2 → 960 x 540 <br> scale = 3 → 1440 x 810 |

**Dicas rápidas:**
- Comece com Tiles de 16x16: É o tamanho mais comum e versátil, equilibrando detalhe e facilidade de criação.
- Prefira o Aspect Ratio 16:9: A maioria dos monitores é widescreen. Usar resoluções base como 256x144 ou 320x180 garante boa escalabilidade para HD e Full HD.
- A "Escolha Segura": Para um novo projeto top-down com tiles de 16x16, uma excelente combinação inicial é:
    - width: 240
    - height: 160
    - scale: 3
    - Resultado: janela de 720x480, confortável para desenvolvimento e com charme retro do GBA.
- Teste a Visibilidade: Resoluções baixas criam sensação mais íntima e limitada; resoluções altas ampliam o campo de visão, mas podem deixar sprites pequenos demais.

---

## Configurando a Resolução do Jogo

A engine oferece um sistema flexível para definir a resolução do seu jogo, utilizando perfis pré-configurados ou permitindo a criação de um perfil customizado.

### Usando um Perfil Pré-pronto

A forma mais fácil de começar é escolher um dos perfis padrão do `enum` `StandardResolutions`. Estes perfis são inspirados em consoles clássicos e garantem um bom aspect ratio para diferentes tamanhos de tile.

```java
// Escolhe um perfil com o estilo do Game Boy Advance
ResolutionProfile profile = StandardResolutions.GBA_STYLE.getProfile();

// Usa o perfil para iniciar a engine
Engine engine = new Engine(profile.width(), profile.height(), profile.recommendedScale(), ...);
```

**Perfis Disponíveis:**

- GBA_STYLE: 240x160 (3:2), clássico e versátil.
- MODERN_16_9_LOW: 256x144 (16:9), ideal para monitores modernos.
- SNES_STYLE: 256x224 (~8:7), para um look mais retro.
- E outros...

### Criando uma Resolução Customizada

Se precisar de um tamanho específico, pode criar o seu próprio `ResolutionProfile` na hora.

```java
// Cria um perfil customizado com resolução base 400x240 e escala 3x
ResolutionProfile profile = new ResolutionProfile(400, 240, 3);

// Inicia a engine com os valores customizados
Engine engine = new Engine(profile.width(), profile.height(), profile.recommendedScale(), ...);
```

---

### 2. Arquitetura Baseada em Componentes (ECS-like)

Em vez de criar hierarquias de classes complexas, a engine adota o padrão **Composição sobre Herança**. A classe `GameObject` é um contêiner vazio ao qual você adiciona funcionalidades através de **Componentes**.

-   **`GameObject`**: A entidade base do jogo. Possui apenas posição, tamanho e uma lista de componentes.
-   **`Component`**: Uma peça de funcionalidade reutilizável. Exemplos:
    -   `Animator`: Cuida das animações.
    -   `PhysicsComponent`: Adiciona gravidade e física de plataforma.
    -   `MovementComponent`: Adiciona movimento controlado pelo jogador.
    -   `AIMovementComponent`: Adiciona inteligência artificial para seguir alvos.
    -   `HealthComponent`: Gerencia vida e dano.

Um jogador, por exemplo, não é uma classe que herda de `Character` que herda de `MovingObject`. Ele é um `GameObject` com os componentes `Animator`, `PhysicsComponent`, `MovementComponent` e `HealthComponent` adicionados a ele.

### 3. Renderização em Camadas (`RenderManager`)

Tudo o que é desenhado na tela é um `IRenderable` e é gerenciado pelo `RenderManager`. O sistema utiliza camadas com profundidade para garantir que os elementos sejam desenhados na ordem correta.

-   **`IRenderable`**: Interface para qualquer objeto desenhável.
-   **`RenderLayer`**: Define uma camada com um nome e uma profundidade (ex: `StandardLayers.CHARACTERS`).
-   **`Z-Order`**: Dentro de uma mesma camada, objetos com `Z-Order` maior (geralmente a posição `y` do objeto) são desenhados por cima, criando um efeito de profundidade 2.5D.

### 4. Sistema de Eventos (Pub/Sub)

Para evitar acoplamento forte entre sistemas, a engine usa um `EventManager` global. Um sistema pode "disparar" um evento, e outros sistemas podem se "inscrever" para ouvir e reagir a esse evento sem se conhecerem diretamente.

-   **Exemplo Prático**: O `PhysicsComponent` não precisa conhecer o `World`. Ele simplesmente se inscreve no evento `EngineEvent.WORLD_LOADED`. Quando o mundo termina de carregar, ele dispara este evento. O `EventManager` notifica todos os inscritos, e só então o `PhysicsComponent` recebe a referência do mundo de que precisa para calcular colisões.

---
[⬅️ Voltar para a Engine](./README.md)