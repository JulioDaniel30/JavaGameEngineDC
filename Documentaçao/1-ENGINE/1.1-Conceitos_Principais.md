# 1.1 - Conceitos Principais da Engine

Para usar a JDStudio Engine de forma eficaz, é crucial entender seus quatro pilares arquitetônicos.

### 1. A Máquina de Estados (`GameState`)

O fluxo do jogo é controlado por uma **Máquina de Estados**. Toda a lógica é separada em "estados" (menu, fase, game over, etc.). A engine gerencia os estados em uma **pilha**, permitindo sobrepor telas (ex: menu de pausa sobre o jogo). Apenas o estado no topo da pilha é atualizado (`tick`), mas todos são renderizados, permitindo a criação de HUDs e efeitos de transparência.

-   **`GameState`**: Classe abstrata que define um estado.
-   **`EnginePlayingState`**: Especialização para fases, gerenciando `GameObject`s.
-   **`EngineMenuState`**: Especialização para menus, gerenciando um `UIManager`.

### 2. Arquitetura Baseada em Componentes (ECS-like)

Em vez de criar hierarquias de classes complexas, a engine adota o padrão **Composição sobre Herança**. A classe `GameObject` é um contêiner vazio ao qual você adiciona funcionalidades através de **Componentes**.

-   **`GameObject`**: A entidade base do jogo. Possui apenas posição, tamanho e uma lista de componentes.
-   **`Component`**: Uma peça de funcionalidade reutilizável. Exemplos:
    -   `Animator`: Cuida das animações.
    -   `PhysicsComponent`: Adiciona gravidade e física de plataforma.
    -   `MovementComponent`: Adiciona movimento controlado pelo jogador.
    -   `AIMovementComponent`: Adiciona inteligência artificial para seguir alvos.
    -   `HealthComponent`: Gerencia vida e dano.

Um jogador, por exemplo, não é uma classe que herda de `Character` que herda de `MovingObject`. Ele é um `GameObject` com os componentes `Animator`, `PhysicsComponent`, `MovementComponent` e `HealthComponent` adicionados a ele.

### 3. Renderização em Camadas (`RenderManager`)

Tudo o que é desenhado na tela é um `IRenderable` e é gerenciado pelo `RenderManager`. O sistema utiliza camadas com profundidade para garantir que os elementos sejam desenhados na ordem correta.

-   **`IRenderable`**: Interface para qualquer objeto desenhável.
-   **`RenderLayer`**: Define uma camada com um nome e uma profundidade (ex: `StandardLayers.CHARACTERS`).
-   **`Z-Order`**: Dentro de uma mesma camada, objetos com `Z-Order` maior (geralmente a posição `y` do objeto) são desenhados por cima, criando um efeito de profundidade 2.5D.

### 4. Sistema de Eventos (Pub/Sub)

Para evitar acoplamento forte entre sistemas, a engine usa um `EventManager` global. Um sistema pode "disparar" um evento, e outros sistemas podem se "inscrever" para ouvir e reagir a esse evento sem se conhecerem diretamente.

-   **Exemplo Prático**: O `PhysicsComponent` não precisa conhecer o `World`. Ele simplesmente se inscreve no evento `EngineEvent.WORLD_LOADED`. Quando o mundo termina de carregar, ele dispara este evento. O `EventManager` notifica todos os inscritos, e só então o `PhysicsComponent` recebe a referência do mundo de que precisa para calcular colisões.